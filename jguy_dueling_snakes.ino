#include <Adafruit_NeoPixel.h>
Adafruit_NeoPixel strip = Adafruit_NeoPixel(64, 15, NEO_GRB + NEO_KHZ800);


/*the display has leds in sequence in a snake pattern, which is changed to x,y coords from 0 to 7 with
  the led[] array, then to read the position it takes the row + 8*column. x,y coords are stored in body */
const int buttons[2][2] = {{14, 16}, {5, 4}}; //[player 1 buttons][player 2 buttons] {{rb1, lb1},{rb2,lb2}}
const int led1 = 0, led2 = 12; //player 1 and 2 win leds
byte locks[2]; //direction change locks for both players (could probably go in properties)
int props[2][3]; //{{dir1, change1, length 1}, {dir2, change2, length 2}}
int body [2][16][2]; //[player], [segment], [coords(r,c)]
const static int bodystart[2][16][2] = {{{5, 7}}, {{2, 0}}}; //player 1 starts at (5,7)
const static int propsstart[2][3] = {{3, 0, 3}, {1, 0, 3}}; //both players have 3 length, player 1 is traveling in the 3 direction, player 2 in 1
int flipper[2][16][2];
int timedraw = 200, needfood = 1, food = 0, w;

//Head down to the way bottom, and look at LEDLocation(x, y).
byte led[64] = {0, 1, 2, 3, 4, 5, 6, 7, 15, 14, 13, 12, 11, 10, 9, 8, 16, 17, 18, 19, 20, 21, 22, 23, 31, 30, 29, 28, 27, 26, 25, 24, 32,
                33, 34, 35, 36, 37, 38, 39, 47, 46, 45, 44, 43, 42, 41, 40, 48, 49, 50, 51, 52, 53, 54, 55, 63, 62, 61, 60, 59, 58, 57, 56
               }; //array the swaps every other row of the matrix to create an x y plane instead of snake pattern

void resetbodies() { //set bodies and properties to their starting position arrays
  for (int i = 0; i < 2; i++) { //for both players
    for (int j = 0; j < 16; j++) { //for all segments
      for (int k = 0; k < 2; k++) { //for both coordinates
        body[i][j][k] = bodystart[i][j][k]; //set the data to the start data
      }
    }
    for (int m = 0; m < 3; m++) { //for all properties
      props[i][m] = propsstart[i][m];//set properties to starting properties
    }
  }
}

void setup() {
  resetbodies(); //set the bodies and properties to their game start values
  pinMode (led1, OUTPUT); //player 1 win led
  pinMode (led2, OUTPUT); //player 2 win led
  for (int i = 0; i < 2; i++) { //for both players
    for (int j = 0; j < 2; j++) { //for both buttons
      pinMode (buttons[i][j], INPUT); //set pinmode input to the button entry
    }
  }
  strip.begin(); //begin led strip
  strip.show();  // initialize all pixels to 'off'
  for (int i = 0; i < 2; i++) { //for both players
    strip.setPixelColor(led[body[i][0][0] + body[i][0][1] * 8], 100 - (100 * i), 0, 255 * i); //set the first pixel on, with color depending on player
  }
  strip.show(); //write to the screen
  Serial.begin (9600); //begin serial moniter
}

//I'm staring at the delay..  Is there a need for it?  Just so you're not spamming the loop()?  Honestly, that's not a problem.
//The program will either spam loop() or it will spam whatever it does to waste time for 20ms.  You're already limiting the game action to
//  your timedraw time, so the game shouldn't change.  I guess it's possible that the multiple digitalRead()s in readbut are slowing things
//  down? I'm not sure how long an individual readbut call takes with multiple digitalRead()s.  I DO know that using print statements and the
//  console will the slow stuff down astronomically, though!
//It would be interesting to see just how long each loop takes.  Due to the slowness of print statements, you'd probably want to just store
//  time lengths for a bunch of frames, and then show them, or the average.
//I don't think delay is causing any harm, but I just don't know if it's needed.
void loop() {
  delay(20); //20ms delay, not long enough to miss button inputs
  for (int i = 0; i < 2; i++) { //for both players
    if (props[i][1] == 0) { // if the direction changer is 0
      props[i][1] = readbut(buttons[i][0], buttons[i][1], i); //set the change in direction equal to the return of the players button readings
    }
  }
  if (millis() > timedraw) { //if statement to draw a single frame after a specified time
    checkfood(); //check if either player is on top of the food
    changedir(); //change the players direction based on the changedir property from the button inputs
    writecoords(); //shift the bodies down their arrays and write a new head coordinate by incrimenting the direction
    checkcolision(); //check if either player has colided with the other, or themselves
    eraseplayer(); //erase the players tail
    drawplayer(); //draw the players head
    if (needfood == 1) { //if a food is needed
      food = createfood(); //set food to a random spot generated by createfood
      needfood = 0; //food spawn is no longer needed
    }
    timedraw = timedraw + 225; //the time incriment do draw a frame
  }
}

//Looks pretty good.  You can use bytes, if you want.  It might be better to do digitalRead() once and store it.  IO (input/output)
//  stuff is always slow compared to saved values, so you'd rather read it once and save it.  And what happens if digitalRead(lb) 
//  changes between the 2 if statements?  Can it?  Or is it updated at some point outside loop()?  You can find out by putting in
//  a delay() between 2 of the if statements, maybe?  I honestly don't know the answer to that.
//int tmp_left = digitalRead(lb);
//int tmp_right = digitalRead(rb);
//if(tmp_left == 0 && tmp_right == 0)  etc etc.
//Snazzy right-left return for getting 1 or negative 1 without using IF statements.
int readbut(int rb , int lb, int l) { //used to translate button inputs into a direction incrimenter when given a player's button pins
	
  if (digitalRead(lb) == 0 && digitalRead(rb) == 0) { //if both buttons are depressed
    locks[l] = 0; //turn the button lock off
    return 0; //no change in direction
  }
  if (digitalRead(rb) != digitalRead(lb) && locks[l] == 0) { //if one button is pressed
    locks[l] = 1; //turn the button lock on 
    return (digitalRead(rb) - digitalRead(lb)); //return either a postive or negitave direction change based on the button readings
  }
  else { //if both buttons are pressed
    return 0; //no direction change
  }
}

void changedir() { //change the players direction based on the changedir property from the button inputs
  for (int i = 0; i < 2; i++) { //for both players
    if (props[i][1] != 0) { //if the direction changer is not 0
      props[i][0] = props[i][0] + props[i][1]; //add the direction changer to the direction
      if (props[i][0] < 0 || props[i][0] > 3) { //if the direction is outside one of the four directions
      	//Wow!  This works, that's for sure!  I'd just do if it's < 0, set it to 3.  if it's > 3, set it to zero.
        props[i][0] = (((props[i][0] + 1) * (-3) / 5) + 3); //warp it back around
      }
      props[i][1] = 0; //set the direction changer to 0
    }
  }
}

//OK, one thing to note here...
//In the first for loop, you're using the potentially updated snake length to adjust locations.  We'll walk through both cases..
//Let's say our snake WAS size 2 last round, and didn't eat, so it's still size 2.
//  We have our snake positions at 0 and 1.  We want to move them to 1 and 2.  (and later we'll delete spot 2 in eraseplayer)
//  This works a-okay.
//Let's say our snake WAS size 2, then we ate 1 food, so our snake is now size 3.  In reality, the snake is still only
//  size 2 at this point.  We move spot 2 to spot 3, then 1 to 2, and 0 to 1.  Later, we'll delete spot 3, which really means
//  we delete nothing.. cause spot 2 was previously empty.  This is fine, since you know it was previously empty.  It's just
//  something to be aware of.... because.... we need to consider a max size!
//Right now, you don't have anything limiting the snake size to 16 (size of the array), or 15 (SAFE size of the snake for your
//  current code).  IF max snake size is 15, then we can move stuff into position 15 from 14.  position 15 is the last position
//  in the array, remember!  But the array technically holds 16 values..  So we coould have a snake size of 16, but this code
//  wouldn't handle it, cause we'd be writing to spot 16.. I guess you would just want to do a check:
//  if (p < max) {body[p] = body[p-1];  etc..};  Since you'll never go above 16, it's okay to just toss that last value, I guess..
//But right.. you're not checking for a max size.  In your checkfood(), you should have a if (size >= 15) { size = 15}..  or somehow
//  limit it.  if it's < (max_size - 1) { size ++;}.
//In arduino, I don't think it check if you go out of bounds on an array, so you'll get really funky behavior.  You can overwrite other
//  values and get phantom errors.
void writecoords() { //shift the bodies down their arrays and write a new head coordinate by incrimenting the direction
  for (int i = 0; i < 2; i++) { //for both players
    for (int p = props[i][2]; p > 0; p--) { //for the length of the body (starting at the end) -- used the shift all segments down
      body[i][p][0] = body[i][p - 1][0]; //set the row coordinate to the previous coordinate
      body[i][p][1] = body[i][p - 1][1]; //set the column coordinate to the previous coordinate
    }
    for (int j = 0; j < 2; j++) { //for both the row and the column coordinate of the head of both snakes
      body[i][0][j] = (body[i][1][j] + (- abs(props[i][0] - 2 + j) + 1)); //incriment the head row based on the current direction
      if (body[i][0][j] > 7 || body[i][0][j] < 0) { //if both the row and the column coordinate are out of bounds
        body[i][0][j] = (((body[i][0][j] + 1) * (-7) / 9) + 7); //warp them around the screen (in bounds is (0 to 7), so -1 goes to 7 and 8 goes to 0)
      }
    }
  }
}

void checkcolision() { //check if either player has colided with the other, or themselves
  if (body[0][0][0] == body[1][0][0] && body[0][0][1] == body[1][0][1]) { //if both heads are occupying the same coordinates
    strip.setPixelColor(led[body[0][0][0] + body[0][0][1] * 8], 100, 0 , 150); //set the color to a mix of red and blue
    flipbodies(); //make the tail the into the head for both players
  }
  else { //if both heads are not on the same coordinates
    for (int i = 0; i < 2; i++) { //for both players
      for (int j = 1; j < props[abs(i - 1)][2]; j++) { //for the length minus one of the other player
        if ((body[i][0][0] == body[abs(i - 1)][j][0]) && (body[i][0][1] == body[abs(i - 1)][j][1])) { //if the players head is coliding with the others body
          end(2 - i); //the game is over, the opposite player to the one being checked wins (either 1 or 2)
        }
      }
      for (int k = 4; k < props[i][2]; k++) { // for the length of the given player, starting at the fifth segment
        if ((body[i][0][0] == body[i][k][0] && body[i][0][1] == body[i][k][1])) { // if the players head is coliding with its own body
          end(2 - i); //the game is over, the opposite player to the one being checked wins (either 1 or 2)
        }
      }
    }
  }
}

void drawplayer() { //draw the players head
  for (int i = 0; i < 2; i++) { //for both players
    strip.setPixelColor(led[body[i][0][0] + body[i][0][1] * 8], 100 - (100 * i), 0, 255 * i); //turn the head pixel on, with color based on the player
  }
  strip.show(); //print to the screen
}

void eraseplayer() { //erase the players tail
  for (int i = 0; i < 2; i++) { //for both players
    strip.setPixelColor(led[body[i][props[i][2]][0] + body[i][props[i][2]][1] * 8], 0, 0, 0); // set the last coordinate in the snake off (last coord = length)
  }
}

int createfood() { //generate a valid food placement
  int f = random(64); //generate a random number 0 - 63
  for (int i = 0; i < 2; i++) { //for both players
    for (int k = 0; k < props[i][2]; k++) { //for the players entie lengths
      if (f == body[i][k][0] + body[i][k][1] * 8) { //if the random number is the position of the body segment
        f = -1; //set f to invalid
        break; 
      }
    }
  }
  if (f == -1) { //if f is invalid
  	//I think you need "return createfood()" rather than just "createfood()".
  	//Alternately, you could pull the "return f;" outside and after the else function.
  	//Right now, you're only returning a value to the loop() if createfood works on the first try.
  	//After that, you return without actually returning a value.  Cause we got the IF statement,
  	//  so then createfood() comes back, and we skip the ELSE statement.  Then it just returns
  	//  with no value!  Maybe it's a value of zero??  What will happen is, you are properly showing
  	//  WHERE the food is, but you're not storing where the food is, so your checkfood won't work 
  	//  correctly.  Maybe it returns zero?  So you need to go get it at the zero point?  I'm not sure!
    return createfood(); //recurse to find a valid random number
  }
  else { //if f is valid
    strip.setPixelColor(led[f], 100, 100, 100); //set the new food on with all colors (white)
    return f; //return the valid foods position
  }
}
//Honestly, this isn't reeeally how recursive functions work.  They are usually bound to a certain limit..
//Liiike, pass in a value of 20, and then we call it, and each time we pass it 1 less, and we have a check
//  for if in_value == 1: Do specific thing, and return.  (do NOT call itself again..).
//It's not like it'll really happen, but you coouuuld be stuck in an infinite (or really long) call chain.
//You really just want something more like this...  just a while loop til you get what you want.  And maybe 
//  limit it, so that you try 10 times, and then just give up and start adding values until it works..
int createfood2()
{
	bool tmp_fail = false;
	byte f = random(64);
	byte tmp_tries = 0;
	bool tmp_found = checkFoodLocation(f);
	while (tmp_found == false && tmp_tries < 10) {
		//it didn't work.. try another one..
		tmp_tries += 1;
		f = random(64);
		tmp_found = checkFoodLocation(f);
	}
	//We got past the while loop.  Sucessfully??
	if (tmp_found == false) {
		//nope!  that means we hit 10 tries.... Now just start adding 1 to our f value.. eventually we'll find 
		//  an open spot....
		//you can use a do{}while() loop, instead of doubling the code..
		//f += 1;
		//tmp_found = checkFoodLocation(f);
		//while (tmp_found == false) {
		do {
			f += 1;
			if (f == 64) {
				f = 0;
			}
			tmp_found = checkFoodLocation(f);
			//we are guaranteed to eventually find one, because the snakes do not fill the entire screen.			
		} while (tmp_found == false);
	}

	//OK, at this point we have a food!  Do the food part..
	strip.setPixelColor(led[f], 100, 100, 100); //set the new food on with all colors (white)
	return f; //return the valid foods position
}

bool checkFoodLocation(byte in_loc)
{
	for (int i = 0; i < 2; i++) { //for both players
		for (int k = 0; k < props[i][2]; k++) { //for the players entire lengths
			if (f == body[i][k][0] + body[i][k][1] * 8) { //if the random number is the position of the body segment
				//random number is on a snake!  fail!
				return false;
			}
		}
	}
	//we got this far, so we are proud to announce that the food is not on a snake!
	return true;	
}


void checkfood() { //check if either player is on the food
  for (int i = 0; i < 2; i++) { //for both players
    if ((body[i][0][0] + body[i][0][1] * 8) == food) { //if the head segment is on the food
    	//Your current snake array only allows for a size up to 16, else you'll get an array out of bounds error..
    	//In arduino, I don't think it checks, so you'll get realy funky behavior.  You can overwrite other values
    	//  and get phantom errors.
      props[i][2]++; //incriment the length up
      needfood = 1; //a new food is needed
    }
  }
}

void flipbodies() { //make the tail into the head for both players (or else its a tie)
  for (int i = 0; i < 2; i++) { //for both players
    for (int j = 0; j < props[i][2]; j++) { //for the length of the player
    	//when you know it's always just going the 2.. X and Y (ie, 0, 1), it's kinda easier to just do
        //  flipper[i][j][0] = body[i][j][0]; // set the flipper array to the body X
        //  flipper[i][j][1] = body[i][j][1]; // set the flipper array to the body Y
        //rather than doing the K forloop.  It's a bit more readable, I think.
      for (int k = 0; k < 2; k++) { //for both the row and column
        flipper[i][j][k] = body[i][j][k]; // set the flipper array to the body
      }
    }
    for (int j = 0; j < props[i][2]; j++) { //for the length of the player, again
      for (int k = 0; k < 2; k++) { //for both the row and the column, again
        body[i][j][k] = flipper[i][props[i][2] - 1 - j][k]; //set the first entry of the body to the last of the flipper, and incriment reverse to flip it
      }
    }
    int drow = body[i][1][0] - body[i][0][0]; //store the change in row from the new second to the new first coordinates
    int dcol = body[i][1][1] - body[i][0][1]; //store the change in column from the new second to the new first coordinates
    if (drow == 0) { //if there is no change in row
      if (dcol != 7 && dcol != -7) { //if the change in column does not wrap around the edge
        props[i][0] = (dcol + 2); //set the new direction based on the change in column (since there can only be either a row or collumn change, not both)
      }
      else { //if the change in column wraps around the edge
        props[i][0] = ((abs(dcol + 7) * (-1) / (7)) + 2); //set the new direction based on the change in column
      }
    }
    else { // if there is a change in row
      if (drow != 7 && drow != -7) { //if the change in rpw does not wrap around the edge
        props[i][0] = abs((drow) - 1); //set the new direction based on the change in row
      }
      else { //if the change in row does wrap around the edge
        props[i][0] = (drow / 7) + 1; ////set the new direction based on the change in row
      }
    }
  }
}

void end(int w) { //if the game is over, give a certian player the win and reset the board
  int i;
  digitalWrite( w * 12 - 12, HIGH); //set a players led on based on the input
  delay(1000); //preserve the board for a second
  int a = 200 - (100 * w); //set the color values for the color wipe based on the winner
  int b = (w * 100) - 100; //set the color values for the color wipe based on the winner
  for (i = 0; i < 64; i++) { // for all pixels
    strip.setPixelColor(i, a, 0, b); //set the color to the winners color
    strip.show(); //write to the screen 
    delay(10); //delay for 10 ms
  }
  delay(100); // delay 100 ms
  digitalWrite( w * 12 - 12, LOW); //turn the winners led off
  for (i = 0; i < 64; i++) { //for all pixels
    strip.setPixelColor(i, 0, 0, 0); //turn the input off
    strip.show(); //write to the screen
    delay(10); //delay 10ms
  }
  resetbodies(); //reset the bodies original position
  timedraw = millis() + 500; //time until first frame is drawn is .5s
  needfood = 1; //another food is needed
}

//Rather than build an led[] array that stores where in the list x,y coords are, we can just create a function.
//IT's a lot easier if you start dealing with stuff that's more than just 64 pixels.
//Now rather than using strip.setPixelColor(led[COMPLICATED_STUFF_EVERYWHERE])),
//  you can just do strip.setPixelColor(LEDLocation(body[0][0][0], body[0][0][1]))..
//If you eventually put multiple panels together, you can include the math here to figure out where in the
//  chain another panel would be..
//  Let's say you stacked 2, so the grid goes from 0,0 to 7, 15.
//We know the first panel is 64 size, so we can something like:
//  if (y > 7) { tmp_extra = 64; y = y - 8;}
//then we just use the same simple calc for a single panel and add tmp_extra to our overall value we return.
//  Makes sense?  (I'm literally pulling this from my own code, haha...)
/* 	------------
 * 	|0,7       |
 * 	|    2     |
 * 	|          |
 * 	|0,0    7,0|
 * 	------------
 * 	|0,7       |
 * 	|    1     |
 * 	|          |
 * 	|0,0    7,0|
 * 	------------
 */

int LEDLocation(byte in_x, byte in_y)
{
	//So we have a snaking pattern...  0 - 7, then 15 - 8, 16 - 23, 31 - 24.

	//even rows (0, 2) will be the easier ones.
	//  3, 0  ->  (8 * 0) + 3 = 3.  yup
	//  3, 2  ->  (8 * 2) * 3 = 19. yup.
	//odd rows (1, 3), will be the "trickier" ones.
	//  0, 1 is 15.   (8 * 1) + 7 - 0 = 15.
	//  1, 1 is 14.   (8 * 1) + 7 - 1 = 14.   yup.	
	if (in_y % 2 == 0) {
		//even rows
		return (8 * in_y) + in_x;
	}
	else {
		//odd rows
		return (8 * in_y) + 7 - in_x;
	}

}

